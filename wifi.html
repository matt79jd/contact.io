<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="theme-color" content="#0b3a66" />
  <title>Welcome – Lynn & Matt’s Home</title>

  <style>
    :root{
      /* Mid-century palette */
      --ink: #10212b;
      --cream: #fff5e6;
      --orange: #f36a2d;
      --yellow: #f6c33b;
      --blue: #1c6dd0;
      --green: #2fa66a;

      --card: rgba(255,255,255,.88);
      --border: rgba(16,33,43,.12);
      --shadow: 0 18px 45px rgba(0,0,0,.14);
      --radius: 22px;
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--ink);
      min-height: 100vh;
      display:grid;
      place-items:center;
      padding: 28px 18px;

      /* Mid-century-ish playful blobs */
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(243,106,45,.22), transparent 55%),
        radial-gradient(900px 600px at 90% 15%, rgba(246,195,59,.22), transparent 60%),
        radial-gradient(900px 600px at 20% 90%, rgba(47,166,106,.18), transparent 60%),
        radial-gradient(900px 600px at 90% 90%, rgba(28,109,208,.18), transparent 60%),
        var(--cream);
    }

    .wrap{ width:100%; max-width: 560px; }

    .card{
      position: relative;
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.86));
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .topBar{
      height: 10px;
      background: linear-gradient(90deg, var(--orange), var(--yellow), var(--green), var(--blue));
    }

    .content{
      padding: 22px 20px 20px;
      text-align: center;
    }

    h1{
      margin: 6px 0 8px;
      font-size: 26px;
      letter-spacing: -0.02em;
      line-height: 1.15;
    }

    .sub{
      margin: 0 0 14px;
      font-size: 14.5px;
      line-height: 1.4;
      opacity: .82;
    }

    .chips{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      margin: 10px 0 18px;
    }

    .chip{
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.65);
      font-weight: 700;
      font-size: 13px;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display:inline-block;
    }
    .dot.orange{ background: var(--orange); }
    .dot.yellow{ background: var(--yellow); }
    .dot.green{ background: var(--green); }
    .dot.blue{ background: var(--blue); }

    .qrWrap{
      margin: 14px auto 10px;
      width: min(320px, 92%);
      padding: 14px;
      border-radius: 20px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.72);
    }

    .qrTitle{
      margin: 0 0 10px;
      font-weight: 900;
      font-size: 13px;
      letter-spacing: .08em;
      text-transform: uppercase;
      opacity: .75;
    }

    canvas{
      width: 100%;
      height: auto;
      border-radius: 16px;
      background: #fff;
      padding: 10px;
      border: 1px solid rgba(0,0,0,.06);
    }

    .fields{
      display:grid;
      gap: 10px;
      margin: 14px 0 6px;
      text-align:left;
      padding: 0 4px;
    }

    .label{
      font-size: 12px;
      letter-spacing: .10em;
      text-transform: uppercase;
      opacity: .75;
      margin-bottom: 6px;
    }

    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 14px;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.78);
      overflow:auto;
      user-select: all;
    }

    .btnRow{
      display:flex;
      gap:10px;
      margin-top: 12px;
    }

    .btn{
      flex:1;
      display:inline-flex;
      justify-content:center;
      align-items:center;
      padding: 13px 12px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.78);
      color: var(--ink);
      text-decoration:none;
      font-weight: 900;
      transition: transform .08s ease, opacity .12s ease;
      position: relative;
      overflow: hidden;
    }
    .btn:active{ transform: scale(.99); opacity: .92; }

    /* Primary button in mid-century blue with a subtle sheen */
    .btn.primary{
      background: linear-gradient(180deg, rgba(28,109,208,1), rgba(16,90,178,1));
      color: #fff;
      border-color: rgba(16,33,43,.08);
      box-shadow: 0 14px 26px rgba(28,109,208,.25);
    }
    .btn.primary::after{
      content:"";
      position:absolute;
      top:-40%;
      left:-35%;
      width:45%;
      height:180%;
      background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.40), rgba(255,255,255,0));
      transform: rotate(18deg) translateX(-140%);
      animation: sheen 3.8s ease-in-out infinite;
      mix-blend-mode: soft-light;
      pointer-events:none;
    }
    @keyframes sheen{
      0%, 60% { transform: rotate(18deg) translateX(-140%); opacity: 0; }
      70%     { opacity: .9; }
      90%     { transform: rotate(18deg) translateX(340%); opacity: 0; }
      100%    { opacity: 0; }
    }

    .hint{
      margin: 12px 0 0;
      font-size: 13px;
      opacity: .78;
      text-align:center;
      padding: 0 10px 14px;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      background: rgba(16,33,43,.92);
      color: #fff;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
    }
    .toast.show{ opacity: 1; }

    @media (prefers-reduced-motion: reduce){
      .btn.primary::after{ animation:none; }
      .toast{ transition:none; }
    }
  </style>
</head>

<body>
  <main class="wrap">
    <section class="card">
      <div class="topBar"></div>

      <div class="content">
        <h1>Welcome to Lynn &amp; Matt’s Home</h1>
        <p class="sub">
          Scan the QR to join the Wi-Fi. If that fails, copy the password.
        </p>

        <div class="chips" aria-label="Vibes">
          <span class="chip"><span class="dot orange"></span> cozy</span>
          <span class="chip"><span class="dot yellow"></span> snacks</span>
          <span class="chip"><span class="dot green"></span> good vibes</span>
          <span class="chip"><span class="dot blue"></span> fast internet</span>
        </div>

        <div class="qrWrap">
          <div class="qrTitle">Wi-Fi QR Code</div>
          <canvas id="qr" width="320" height="320" aria-label="Wi-Fi QR code"></canvas>
        </div>

        <div class="fields">
          <div>
            <div class="label">Network name (SSID)</div>
            <div class="mono" id="ssidText">YOUR_WIFI_NAME</div>
          </div>
          <div>
            <div class="label">DunderMifflin-Guest</div>
            <div class="mono" id="pwText">3nF$oOs9!bGb4</div>
          </div>
        </div>

        <div class="btnRow">
          <a class="btn primary" href="#" id="copyPwBtn">Copy Password</a>
          <a class="btn" href="#" id="copySsidBtn">Copy SSID</a>
        </div>

        <div class="hint">
          iPhone: open Camera and point at the QR → “Join Network”.<br/>
          If you’re already here via NFC, you’re basically done.
        </div>
      </div>
    </section>
  </main>

  <div class="toast" id="toast">Copied</div>

  <script>
    /************************************************************
     * EDIT THESE TWO LINES
     ************************************************************/
    const SSID = "DunderMifflin-Guest";
    const PASS = "3nF$oOs9!bGb4";

    // WPA works for WPA2/WPA3 Personal.
    const AUTH = "WPA";
    const HIDDEN = false;

    // Update visible text
    document.getElementById("ssidText").textContent = SSID;
    document.getElementById("pwText").textContent = PASS;

    // Copy helpers
    const toast = document.getElementById("toast");
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(()=>toast.classList.remove("show"), 1100);
    }
    async function copyText(text, label){
      try{
        await navigator.clipboard.writeText(text);
        showToast(label + " copied");
      }catch(e){
        showToast("Tap & hold to copy");
      }
    }
    document.getElementById("copyPwBtn").addEventListener("click", (e)=>{
      e.preventDefault(); copyText(PASS, "Password");
    });
    document.getElementById("copySsidBtn").addEventListener("click", (e)=>{
      e.preventDefault(); copyText(SSID, "SSID");
    });

    /************************************************************
     * WIFI QR Payload:
     * WIFI:T:WPA;S:SSID;P:PASSWORD;H:false;;
     ************************************************************/
    function escWifi(s){ return String(s).replace(/([\\;,:"])/g, "\\$1"); }
    const wifiPayload = `WIFI:T:${AUTH};S:${escWifi(SSID)};P:${escWifi(PASS)};H:${HIDDEN ? "true" : "false"};;`;

    /************************************************************
     * Minimal QR generator (small, local, no external services)
     * Based on the classic qrcode-generator approach.
     ************************************************************/
    // ---- begin tiny QR ----
    const QRMode = { MODE_8BIT_BYTE: 1 };
    const QRErrorCorrectLevel = { L:1, M:0, Q:3, H:2 };

    function QRBitBuffer(){ this.buffer=[]; this.length=0; }
    QRBitBuffer.prototype = {
      get(i){ const b=Math.floor(i/8); return ((this.buffer[b] >>> (7 - i%8)) & 1) === 1; },
      put(num, length){ for(let i=0;i<length;i++) this.putBit(((num >>> (length - i - 1)) & 1) === 1); },
      putBit(bit){
        const b=Math.floor(this.length/8);
        if(this.buffer.length<=b) this.buffer.push(0);
        if(bit) this.buffer[b] |= (0x80 >>> (this.length % 8));
        this.length++;
      }
    };

    function QR8BitByte(data){ this.mode=QRMode.MODE_8BIT_BYTE; this.data=data; }
    QR8BitByte.prototype = {
      getLength(){ return this.data.length; },
      write(buffer){ for(let i=0;i<this.data.length;i++) buffer.put(this.data.charCodeAt(i),8); }
    };

    // Galois field / Reed-Solomon helpers (compact)
    const QRMath = (function(){
      const EXP_TABLE = new Array(256);
      const LOG_TABLE = new Array(256);
      for(let i=0;i<8;i++) EXP_TABLE[i] = 1 << i;
      for(let i=8;i<256;i++) EXP_TABLE[i] = EXP_TABLE[i-4] ^ EXP_TABLE[i-5] ^ EXP_TABLE[i-6] ^ EXP_TABLE[i-8];
      for(let i=0;i<255;i++) LOG_TABLE[EXP_TABLE[i]] = i;
      return {
        glog(n){ if(n<1) throw new Error("glog"); return LOG_TABLE[n]; },
        gexp(n){
          while(n<0) n += 255;
          while(n>=256) n -= 255;
          return EXP_TABLE[n];
        }
      };
    })();

    function QRPolynomial(num, shift){
      let offset=0;
      while(offset<num.length && num[offset]===0) offset++;
      this.num = new Array(num.length - offset + shift);
      for(let i=0;i<num.length-offset;i++) this.num[i] = num[i+offset];
    }
    QRPolynomial.prototype = {
      getAt(i){ return this.num[i]; },
      getLength(){ return this.num.length; },
      multiply(e){
        const num = new Array(this.getLength() + e.getLength() - 1).fill(0);
        for(let i=0;i<this.getLength();i++){
          for(let j=0;j<e.getLength();j++){
            num[i+j] ^= QRMath.gexp(QRMath.glog(this.getAt(i)) + QRMath.glog(e.getAt(j)));
          }
        }
        return new QRPolynomial(num, 0);
      },
      mod(e){
        if(this.getLength() - e.getLength() < 0) return this;
        const ratio = QRMath.glog(this.getAt(0)) - QRMath.glog(e.getAt(0));
        const num = this.num.slice();
        for(let i=0;i<e.getLength();i++){
          num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i)) + ratio);
        }
        return new QRPolynomial(num,0).mod(e);
      }
    };

    const QRRSBlock = (function(){
      // Table for versions 1–10 (enough for home Wi-Fi strings)
      // Each entry: [ (count, totalCount, dataCount), ... ]
      const RS_BLOCK_TABLE = [
        null,
        [1,26,19], [1,44,34], [1,70,55], [1,100,80], [1,134,108],
        [2,86,68], [2,98,78], [2,121,97], [2,146,116], [2,86,68]
      ];
      function getRSBlocks(typeNumber, errorCorrectLevel){
        // We’ll use M for a good balance
        const t = RS_BLOCK_TABLE[typeNumber];
        if(!t) throw new Error("RSBlock");
        const list=[];
        for(let i=0;i<t.length;i+=3){
          const count=t[i], total=t[i+1], data=t[i+2];
          for(let c=0;c<count;c++) list.push({totalCount:total, dataCount:data});
        }
        return list;
      }
      return { getRSBlocks };
    })();

    function QRUtil(){}
    QRUtil.PATTERN_POSITION_TABLE = [
      [], [6,18], [6,22], [6,26], [6,30], [6,34], [6,22,38], [6,24,42], [6,26,46], [6,28,50], [6,30,54]
    ];
    QRUtil.G15 = (1<<10) | (1<<8) | (1<<5) | (1<<4) | (1<<2) | (1<<1) | (1<<0);
    QRUtil.G18 = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8) | (1<<5) | (1<<2) | (1<<0);
    QRUtil.G15_MASK = (1<<14) | (1<<12) | (1<<10) | (1<<4) | (1<<1);
    QRUtil.getBCHDigit = function(data){
      let digit=0;
      while(data!==0){ digit++; data >>>= 1; }
      return digit;
    };
    QRUtil.getBCHTypeInfo = function(data){
      let d = data << 10;
      while(QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0){
        d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15)));
      }
      return ((data << 10) | d) ^ QRUtil.G15_MASK;
    };
    QRUtil.getPatternPosition = function(typeNumber){ return QRUtil.PATTERN_POSITION_TABLE[typeNumber]; };
    QRUtil.getMask = function(maskPattern, i, j){
      switch(maskPattern){
        case 0: return (i + j) % 2 === 0;
        case 1: return i % 2 === 0;
        case 2: return j % 3 === 0;
        case 3: return (i + j) % 3 === 0;
        case 4: return (Math.floor(i/2) + Math.floor(j/3)) % 2 === 0;
        case 5: return (i*j)%2 + (i*j)%3 === 0;
        case 6: return ((i*j)%2 + (i*j)%3) % 2 === 0;
        case 7: return ((i+j)%2 + (i*j)%3) % 2 === 0;
        default: throw new Error("mask");
      }
    };

    function QRCode(typeNumber, errorCorrectLevel){
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }

    QRCode.prototype = {
      addData(data){ this.dataList.push(new QR8BitByte(data)); this.dataCache = null; },
      isDark(row, col){ return this.modules[row][col]; },
      getModuleCount(){ return this.moduleCount; },

      make(){
        if(this.typeNumber < 1){
          this.typeNumber = 1;
        }
        this.makeImpl(false, 0);
      },

      makeImpl(test, maskPattern){
        this.moduleCount = this.typeNumber * 4 + 17;
        this.modules = new Array(this.moduleCount);
        for(let row=0; row<this.moduleCount; row++){
          this.modules[row] = new Array(this.moduleCount).fill(null);
        }
        this.setupPositionProbePattern(0,0);
        this.setupPositionProbePattern(this.moduleCount - 7, 0);
        this.setupPositionProbePattern(0, this.moduleCount - 7);
        this.setupTimingPattern();
        this.setupPositionAdjustPattern();
        this.setupTypeInfo(test, maskPattern);

        if(this.dataCache === null){
          this.dataCache = this.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
        }
        this.mapData(this.dataCache, maskPattern);
      },

      setupPositionProbePattern(row, col){
        for(let r=-1; r<=7; r++){
          if(row+r <= -1 || this.moduleCount <= row+r) continue;
          for(let c=-1; c<=7; c++){
            if(col+c <= -1 || this.moduleCount <= col+c) continue;
            if((0<=r && r<=6 && (c===0 || c===6)) ||
               (0<=c && c<=6 && (r===0 || r===6)) ||
               (2<=r && r<=4 && 2<=c && c<=4)){
              this.modules[row+r][col+c] = true;
            } else {
              this.modules[row+r][col+c] = false;
            }
          }
        }
      },

      setupTimingPattern(){
        for(let i=8; i<this.moduleCount-8; i++){
          if(this.modules[i][6] === null) this.modules[i][6] = (i % 2 === 0);
          if(this.modules[6][i] === null) this.modules[6][i] = (i % 2 === 0);
        }
      },

      setupPositionAdjustPattern(){
        const pos = QRUtil.getPatternPosition(this.typeNumber);
        for(let i=0; i<pos.length; i++){
          for(let j=0; j<pos.length; j++){
            const row = pos[i], col = pos[j];
            if(this.modules[row][col] !== null) continue;
            for(let r=-2; r<=2; r++){
              for(let c=-2; c<=2; c++){
                if(r===-2 || r===2 || c===-2 || c===2 || (r===0 && c===0)){
                  this.modules[row+r][col+c] = true;
                } else {
                  this.modules[row+r][col+c] = false;
                }
              }
            }
          }
        }
      },

      setupTypeInfo(test, maskPattern){
        // errorCorrectLevel: use M (0) for our table
        const data = (QRErrorCorrectLevel.M << 3) | maskPattern;
        const bits = QRUtil.getBCHTypeInfo(data);

        // vertical
        for(let i=0; i<15; i++){
          const mod = (!test && ((bits >> i) & 1) === 1);
          if(i<6) this.modules[i][8] = mod;
          else if(i<8) this.modules[i+1][8] = mod;
          else this.modules[this.moduleCount - 15 + i][8] = mod;
        }
        // horizontal
        for(let i=0; i<15; i++){
          const mod = (!test && ((bits >> i) & 1) === 1);
          if(i<8) this.modules[8][this.moduleCount - i - 1] = mod;
          else if(i<9) this.modules[8][15 - i - 1 + 1] = mod;
          else this.modules[8][15 - i - 1] = mod;
        }
        this.modules[this.moduleCount - 8][8] = (!test);
      },

      createData(typeNumber, errorCorrectLevel, dataList){
        const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
        const buffer = new QRBitBuffer();

        for(let i=0; i<dataList.length; i++){
          const data = dataList[i];
          buffer.put(data.mode, 4);
          buffer.put(data.getLength(), 8);
          data.write(buffer);
        }

        let totalDataCount = 0;
        for(let i=0; i<rsBlocks.length; i++) totalDataCount += rsBlocks[i].dataCount;

        // terminator
        if(buffer.length + 4 <= totalDataCount * 8) buffer.put(0,4);
        while(buffer.length % 8 !== 0) buffer.putBit(false);

        // pad bytes
        const PAD0 = 0xEC, PAD1 = 0x11;
        while(buffer.length < totalDataCount * 8){
          buffer.put(PAD0, 8);
          if(buffer.length >= totalDataCount * 8) break;
          buffer.put(PAD1, 8);
        }

        // to bytes
        let offset = 0;
        const dataBytes = [];
        while(offset < totalDataCount){
          dataBytes.push(0);
          offset++;
        }
        for(let i=0; i<dataBytes.length; i++){
          dataBytes[i] = 0;
          for(let j=0; j<8; j++){
            if(buffer.get(i*8 + j)) dataBytes[i] |= (0x80 >>> j);
          }
        }

        // split into blocks + RS
        let maxDc = 0, maxEc = 0;
        const dcdata = [];
        const ecdata = [];
        let index = 0;

        for(let r=0; r<rsBlocks.length; r++){
          const dcCount = rsBlocks[r].dataCount;
          const ecCount = rsBlocks[r].totalCount - dcCount;
          maxDc = Math.max(maxDc, dcCount);
          maxEc = Math.max(maxEc, ecCount);

          dcdata[r] = dataBytes.slice(index, index + dcCount);
          index += dcCount;

          const rsPoly = (function(ecCount){
            let poly = new QRPolynomial([1],0);
            for(let i=0;i<ecCount;i++){
              poly = poly.multiply(new QRPolynomial([1, QRMath.gexp(i)],0));
            }
            return poly;
          })(ecCount);

          const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
          const modPoly = rawPoly.mod(rsPoly);

          ecdata[r] = new Array(rsPoly.getLength() - 1).fill(0);
          const modLen = modPoly.getLength();
          for(let i=0;i<ecdata[r].length;i++){
            const modIndex = i + modLen - ecdata[r].length;
            ecdata[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
          }
        }

        // interleave
        const totalCodeCount = rsBlocks.reduce((a,b)=>a+b.totalCount,0);
        const code = new Array(totalCodeCount);
        let p = 0;

        for(let i=0; i<maxDc; i++){
          for(let r=0; r<rsBlocks.length; r++){
            if(i < dcdata[r].length) code[p++] = dcdata[r][i];
          }
        }
        for(let i=0; i<maxEc; i++){
          for(let r=0; r<rsBlocks.length; r++){
            if(i < ecdata[r].length) code[p++] = ecdata[r][i];
          }
        }
        return code;
      },

      mapData(data, maskPattern){
        let inc = -1;
        let row = this.moduleCount - 1;
        let bitIndex = 7;
        let byteIndex = 0;

        for(let col=this.moduleCount-1; col>0; col-=2){
          if(col === 6) col--;
          while(true){
            for(let c=0; c<2; c++){
              if(this.modules[row][col - c] === null){
                let dark = false;
                if(byteIndex < data.length){
                  dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
                }
                const mask = QRUtil.getMask(maskPattern, row, col - c);
                this.modules[row][col - c] = mask ? !dark : dark;

                bitIndex--;
                if(bitIndex === -1){
                  byteIndex++;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if(row < 0 || this.moduleCount <= row){
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      }
    };

    function pickVersionFor(dataStr){
      // naive but effective: try versions 1..10 until it fits
      for(let v=1; v<=10; v++){
        try{
          const qr = new QRCode(v, QRErrorCorrectLevel.M);
          qr.addData(dataStr);
          qr.make();
          return qr;
        }catch(e){}
      }
      // fallback: version 10
      const qr = new QRCode(10, QRErrorCorrectLevel.M);
      qr.addData(dataStr);
      qr.make();
      return qr;
    }

    function drawQR(qr){
      const canvas = document.getElementById("qr");
      const ctx = canvas.getContext("2d");
      const count = qr.getModuleCount();

      // crisp rendering
      const size = canvas.width;
      const cell = Math.floor(size / count);
      const margin = Math.floor((size - cell * count) / 2);

      ctx.clearRect(0,0,size,size);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,size,size);

      ctx.fillStyle = "#000000";
      for(let r=0; r<count; r++){
        for(let c=0; c<count; c++){
          if(qr.isDark(r,c)){
            ctx.fillRect(margin + c*cell, margin + r*cell, cell, cell);
          }
        }
      }
    }

    const qr = pickVersionFor(wifiPayload);
    drawQR(qr);
    // ---- end tiny QR ----
  </script>
</body>
</html>
